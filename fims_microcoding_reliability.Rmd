---
title: "fims_microcoding_reliability"
author: "Fran Querdasi"
date: "2023-02-09"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup
## Load libraries
```{r}
suppressPackageStartupMessages({
  library(stringr)
  library(stringi)
  library(readxl) 
  library(purrr)
  library(lubridate)
  library(irr) #for cohen's kappa
  source("fims_microcoding_helper_functions.R")
  library(reshape2)
  library(tidyverse)
})
```

## Load data
For reliability, during Winter 2023 only affect codes will be tested, and only one interaction will be coded for each participant. 

```{r}
reliability_codes <- "../../../../Lab/Video_coding_fims_micro/fims_micro" #overall directory where all of the codes

#get all of the .txt files from within the overall directory
fl <- list.files(path=reliability_codes, pattern = "*.txt", recursive=TRUE, full.names = TRUE) #this will output a list of the files

#get a list of empty files from df to exclude for reading in (otherwise r with throw an error)
empty <- fl[file.size(fl) == 0L]

#read in all the coder files
read_reliability_files <- function(fl) {
list_name <- "reliability_dfs"
list <- list()
for (i in 1:length(fl)) { #for each file in the list
  #if file and folder name match, and the file is not empty...
  if ((gsub("fims_micro/", "", str_match(fl[[i]], "micro/(.*?)/fims")[2]) == str_match(fl[[i]], "affect/(.*?)_[A-Za-z]")[2]) & !(fl[[i]] %in% empty)) {
    #get info to add to the dfs
    id_file_name <- str_match(fl[[i]], "affect/(.*?)_[A-Za-z]")[2] #this is the participant id
    coder_initials <- str_match(fl[[i]], "Micro_(.*?).txt")[2]
    #read the file into r, create column names
    df <- read.table(fl[[i]], header=FALSE, fill=TRUE, sep="\t")
    colnames(df) <- c("Tier", "Participant", "Time", str_c(coder_initials, "_code")) #column names are Tier, Participant, Time, and <coder initials>_code
    #set the df name to match the participant: <id_file_name>_<child|parent>
    df_name <- str_c(id_file_name, "_", tolower(df$Participant[1]), "_", coder_initials) #need to add coder initials so that they're not all the same name
    #assign df to the list
    list[[i]] <- df 
    names(list)[i] <- df_name
  } else if (fl[[i]] %in% empty) { #else if the file is empty...
    #write a message telling the person that the file name is empty and not being read in
    print(paste0(str_match(fl[[i]], 'affect/(.*)')[2], " is empty -- not being read into R"))
  } else { #if the file and folder name do not match...
    #write a message saying to check naming
    print(paste0("file ", str_match(fl[[i]], 'affect/(.*)')[2], " and folder ", gsub("fims_micro/", "", str_match(fl[[i]], "micro/(.*?)/fims")[2]), " names do not match, not being read into R now -- please check"))
  }
}
#assign the list to the global environment
assign(list_name, list, envir=.GlobalEnv)
}

#apply the function
read_reliability_files(fl)
```

# Merge reliability files by participant
```{r}
#filter out "" entries that got fed in somehow 
reliability_dfs <- reliability_dfs[which(names(reliability_dfs)!="")]

#change the time variable to be double in all dfs
for (i in 1:length(reliability_dfs)) {
  if (is.character(reliability_dfs[[i]]$Time)) { #if the time variable is a character...
    reliability_dfs[[i]]$Time <- as.numeric(lubridate::hms(reliability_dfs[[i]]$Time)) #convert it to hh:mm:ss and then to numeric
  }
}

#get the names of all the dataframes
reliability_df_names <- sort(names(reliability_dfs)) #names of the coder dfs

#for all of the names_of_dfs, if cons_df_names contains the name, then full_join it with the df that contains it on Tier and Time
merge_reliability_dfs <- function(reliability_dfs, reliability_df_names) {
list_name <- "merged_dfs" #set the name of the output list
list <- list() #initialize an empty list to fill below
for (i in 1:(length(reliability_df_names)-1)) { #for all of the reliability dfs
    #if the name of the first df (e.g., MBB_2_074_parent_MA) has the same name as the next df minus the coder initials,
    if (str_detect(str_sub(reliability_df_names[i], start=1, end=(stri_locate_first_regex(reliability_df_names[i], "_[A-Z]")[1]-1)), str_sub(reliability_df_names[i+1], start=1, end=(stri_locate_first_regex(reliability_df_names[i+1], "_[A-Z]")[1]-1)))) {
      #assign the name of the df to be the name of the first file minus coder initials
      df_name <- str_sub(reliability_df_names[i], start=1, end=(stri_locate_first_regex(reliability_df_names[i], "_[A-Z]")[1]-1))
      if (!exists(df_name)) { #if the df has not already been made...
      df1 <- reliability_dfs[[reliability_df_names[i]]] %>% dplyr::left_join(reliability_dfs[[reliability_df_names[i+1]]], by = c("Tier", "Participant", "Time")) 
      list[[i]] <- assign(df_name, df1, envir=.GlobalEnv) #assign the df to the global environment (need to do for this loop so that next time it runs can tell if it was made already or not)
      names(list)[i] <- df_name #name the df
      }
      else { #if it has been made already...
      print(paste0("there are more than 2 files for participant ", str_sub(reliability_df_names[i], start=1, end=(stri_locate_first_regex(reliability_df_names[i], "_[A-Z]")[1]-1)), ", only the first 2 being read"))
     } 
  }
}
#assign the completed list to the global environment
assign(list_name, list, envir=.GlobalEnv)
}

#apply the function
merge_reliability_dfs(reliability_dfs, reliability_df_names)

#remove the null entries in the list (from files that were not read in)
merged_dfs = merged_dfs[-which(sapply(merged_dfs, is.null))]
```

# Create the individual second agreement/disagreement files
(1 for each participant_child/parent file) 
coders_agree variable as well as relative time
```{r}
#create the variables (relative time, binary agree for each pair of coders)
for (df_name in names(merged_dfs)) {
  #get column names that contain coders' codes
  coders <- colnames(merged_dfs[[df_name]])[which(str_detect(colnames(merged_dfs[[df_name]]), "_code$"))]
  #create binary 1/0 agreement variable between each pair of coders
  merged_dfs[[df_name]] <- mutate(merged_dfs[[df_name]], coders_agree := case_when(
      #if the string is found in the coder code and consensus code, variable is 1
      grepl("neutral", get(coders[1])) & grepl("neutral", get(coders[2])) ~ 1, 
      grepl("positive", get(coders[1])) & grepl("positive", get(coders[2])) ~ 1,
      grepl("dysphoric", get(coders[1])) & grepl("dysphoric", get(coders[2])) ~ 1,
      grepl("angry", get(coders[1])) & grepl("angry", get(coders[2])) ~ 1,
      grepl("uncodable", get(coders[1])) & grepl("uncodable", get(coders[2])) ~ 1,
      grepl("end", get(coders[1])) & grepl("end", get(coders[2])) ~ 1,
      grepl("start", get(coders[1])) & grepl("start", get(coders[2])) ~ 1,
      is.na(get(coders[1])) | is.na(get(coders[2])) ~ NA_real_,  #if there is NA in either consensus code or coder code, value is NA
      TRUE ~ 0 #otherwise if none of the above are met, value is 0
  ), 
  relative_time = round(Time - Time[1], digits=0)) #relative time is Time minus initial time, rounded to nearest integer
}
```

## Write individual participant files with binary agreement per code
Need to write in correct path
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_reliability_data/" #path to write the files

#for each entry in the merged_dfs list, write the entry as a .csv called "name_agreement.csv"
lapply(1:length(merged_dfs), function(i) write.csv(merged_dfs[[i]], 
                                      file = paste0(str_c(path, names(merged_dfs)[i], "_agreement.csv", sep="")),
                                      row.names = FALSE))

#NULLs output below mean that writing the file was successful 
```

# Create summary file for each participant
## Create binary columns for whether each coder indicated a specific code
These will be used in percent agreement, base rates, and kappas
% agreement for each code = if 1 in both columns OR if 0 in both columns --> add to number of agreements; if 1 and 0 --> number of disagreements
Formula = agreements/(sum of all rows, both agreements and disagreements)

```{r}
for (df_name in names(merged_dfs)) {
#get column names that contain coders' codes
coders <- colnames(merged_dfs[[df_name]])[which(str_detect(colnames(merged_dfs[[df_name]]), "_code$"))]
#create binary 'did the coder indicate this code' for each code
merged_dfs[[df_name]] <- mutate(merged_dfs[[df_name]], 
   across(ends_with("_code"), ~ifelse(grepl("neutral", .), 1, 0), .names="neutral_{sub('_code', '', col)}"),
   across(ends_with("_code"), ~ifelse(grepl("positive", .), 1, 0), .names="positive_{sub('_code', '', col)}"),
   across(ends_with("_code"), ~ifelse(grepl("uncodable", .), 1, 0), .names="uncodable_{sub('_code', '', col)}"),
   across(ends_with("_code"), ~ifelse(grepl("dysphoric", .), 1, 0), .names="neg_dys_{sub('_code', '', col)}"),
   across(ends_with("_code"), ~ifelse(grepl("angry", .), 1, 0), .names="neg_angry_{sub('_code', '', col)}"),
   across(ends_with("_code"), ~ifelse(grepl("angry", .) | grepl("dysphoric", .), 1, 0), .names="gen_neg_{sub('_code', '', col)}")
) 
}

```

## Calculate reliability metrics for each participant, total and for each code
Total = sum of '1's in coders_agree column/sum(!is.na(.))
each code = sum of 'agreements' in that column divided by total rows that are not NA across both
```{r}
calc_reliability_participant <- function(merged_dfs) {
  list_name <- "participant_summary_dfs"
  list <- list()
  for (i in 1:length(merged_dfs)) {
    #create the final df name
    final_df_name <- str_c(names(merged_dfs)[i], "_summary", sep="")
    
    #get list of coder columns and codes
    coders <- colnames(merged_dfs[[names(merged_dfs)[i]]])[which(str_detect(colnames(merged_dfs[[names(merged_dfs)[i]]]), "_code$"))] 
    codes <- c("neutral", "positive", "uncodable", "neg_dys", "neg_angry", "gen_neg","total")
    
    #create empty dfs to percent agreements
    participant_summary_df <- data.frame(matrix(NA, nrow=5, ncol=length(codes))) #rows will be "perc_agree", "presence_agree", "kappa", "baserate_c1", "baserate_c2"
    #columns will be code1, code2, etc 
    
    #calculate reliability metrics (percent agreement, kappas, and base rates) put in df
    for (j in 1:length(codes)){
        if (codes[j] != "total") { #for all codes except total...
          coder1_col_name = str_c(codes[j], sub("_code", "", coders[1]), sep="_") #coder1 dummy code column name e.g., neutral_MA
          coder2_col_name = str_c(codes[j], sub("_code", "", coders[2]), sep="_") #coder2 dummy code column name neutral_CB
          #percent agreement
          participant_summary_df[1, j] = (sum(apply(merged_dfs[[i]][,startsWith(colnames(merged_dfs[[i]]), codes[j])]==1, 1, all)) + sum(apply(merged_dfs[[i]][,startsWith(colnames(merged_dfs[[i]]), codes[j])]==0, 1, all)))/sum(apply(!is.na(merged_dfs[[i]][,startsWith(colnames(merged_dfs[[i]]), codes[j])]), 1, all))
          colnames(participant_summary_df)[j] <- paste0(codes[j]) #name the column "neutral"
          rownames(participant_summary_df)[1] <- paste0("percent_agree") #name the row "MA_code_agree"
          
          #presence agreement
          participant_summary_df[2, j] = (sum(apply(merged_dfs[[i]][,startsWith(colnames(merged_dfs[[i]]), codes[j])]==1, 1, all)))/sum(merged_dfs[[i]][, coder1_col_name] == 1 | merged_dfs[[i]][, coder2_col_name] == 1, na.rm=T) #total number of times both cols are 1 divided by nrows with any instances of that code
          colnames(participant_summary_df)[j] <- paste0(codes[j]) #name the column "neutral"
          rownames(participant_summary_df)[2] <- paste0("presence_agree") #
          
          #kappas
          participant_summary_df[3, j] = kappa2(cbind(merged_dfs[[i]][[coder1_col_name]], merged_dfs[[i]][[coder2_col_name]]))$value
          colnames(participant_summary_df)[j] <- paste0(codes[j])
          rownames(participant_summary_df)[3] <- paste0("kappa")
     
          #base rates for each coder and code
          participant_summary_df[4, j] = sum(merged_dfs[[i]][[coder1_col_name]], na.rm=T)/sum(!is.na(merged_dfs[[i]][[coder1_col_name]]))
          rownames(participant_summary_df)[4] <- paste0(str_c("baserate", sub("_code", "", coders[1]), sep="_"))
          participant_summary_df[5, j] = sum(merged_dfs[[i]][[coder2_col_name]], na.rm=T)/sum(!is.na(merged_dfs[[i]][[coder2_col_name]]))
          rownames(participant_summary_df)[5] <- paste0(str_c("baserate", sub("_code", "", coders[2]), sep="_"))
          }
        else { #do a different procedure for total
          #percent agreement
          overall_agree_col <- "coders_agree"
          participant_summary_df[1, j] = sum(merged_dfs[[i]][[overall_agree_col]], na.rm=T)/sum(!is.na(merged_dfs[[i]][[overall_agree_col]]))
          colnames(participant_summary_df)[j] <- paste0(codes[j])
          rownames(participant_summary_df)[1] <- paste0("percent_agree")
          
          #total kappa
          participant_summary_df[3 , j] <- kappa2(cbind(merged_dfs[[i]][[coders[1]]], merged_dfs[[i]][[coders[2]]]))$value #calculate total kappa, add new variable 
          colnames(participant_summary_df)[j] <- paste0(codes[j])
          rownames(participant_summary_df)[3] <- paste0("kappa") 
        }
      }
    #create 'coder' first column
    participant_summary_df <- rownames_to_column(participant_summary_df, var = "statistic")
    list[[i]] <-  participant_summary_df 
    names(list)[i] <- final_df_name
  }
  #assign the completed list to the global environment
  assign(list_name, list, envir=.GlobalEnv)
}

#apply the function
calc_reliability_participant(merged_dfs) 

#diagnosing error: are there NAs in any merged_df?
for (i in 1:length(merged_dfs)) {
  print(paste0("there are ", sum(is.na(merged_dfs[[i]])), " NAs in ", names(merged_dfs[i])))
}
```

## Write the summary file for each participant
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_reliability_data/" #path to write the files

#for each entry in the indiv_dfs kappas and % agreement list, write a .csv
lapply(1:length(participant_summary_dfs), function(i) write.csv(participant_summary_dfs[[i]], 
                                      file = paste0(str_c(path, names(participant_summary_dfs)[i], ".csv", sep="")), #call participantid_parent/child_summary
                                      row.names = FALSE))
```

# Create summary file across all participants
## Partition the data
## Create total df with all participants and coders
Kappa (total, each code) across all coders and participants
Base rates for each coder across all participants
```{r}
#create a participant id variable, useful when merging across multiple dfs
for (i in 1:(length(merged_dfs))) {
  merged_dfs[[i]]$participant_id <- names(merged_dfs)[i] 
}

#merge the list of dfs to create one really long df
mega_df <- bind_rows(merged_dfs)
```

### Subset mega_df into separate dfs for each coder across all participants
Kappa (total, each code), base rates, percent agreement for each pair of coders across all participants that they coded
```{r}
#subset this into separate dfs for each coder
split_coder_dfs <- function(mega_df) {
  all_coders <- colnames(mega_df)[which(str_detect(colnames(mega_df), "_code$"))] 
  coder_pairs <- combn(unique(1:length(all_coders)), 2) #get all the unique combinations of coders
  
  coder_dfs <- list()
  coder_df_name <- "coder_dfs"
  
  for (p in 1:ncol(coder_pairs)){
     #if there are any rows where both coders' columns in the pair are not NA...
    if(nrow(mega_df[!is.na(mega_df[,all_coders[coder_pairs[1, p]]]) & !is.na(mega_df[,all_coders[coder_pairs[2, p]]]),]) >0) {
      df <- mega_df[!is.na(mega_df[all_coders[coder_pairs[1, p]]]) & !is.na(mega_df[all_coders[coder_pairs[2, p]]]), ] %>% dplyr::select(
        Tier, 
        Participant, 
        participant_id,
        Time, 
        relative_time,
        coders_agree,
        contains(sub("_code", "", all_coders[coder_pairs[1, p]])),
        contains(sub("_code", "", all_coders[coder_pairs[2, p]]))
      )
      df_name <- paste0(str_c(sub("_code", "", all_coders[coder_pairs[1, p]]), sub("_code", "", all_coders[coder_pairs[2, p]]), "codes", sep="_"))
      coder_dfs[[p]] <-  df 
      names(coder_dfs)[p] <- df_name
    }
  }
  assign(coder_df_name, coder_dfs, envir=.GlobalEnv)
}

split_coder_dfs(mega_df)

#remove the 'null' entries in the list
coder_dfs = coder_dfs[-which(sapply(coder_dfs, is.null))]
```

## Subset mega_df into parent and child participants
```{r}
parents <- mega_df %>% dplyr::filter(Participant=="Parent") %>% dplyr::select(where(~sum(!is.na(.x)) > 0)) #remove columns for coders that are all NA (they didn't code parent files)

children <- mega_df %>% dplyr::filter(Participant=="Child") %>% dplyr::select(where(~sum(!is.na(.x)) > 0))
```


## Calculate the statistics
### Calculate base rates for each coder across all coderpairs and participants, and within all parent and all child files
```{r}
#get list of all coders
all_coders <- colnames(mega_df)[which(str_detect(colnames(mega_df), "_code$"))] 
child_coders <- colnames(children)[which(str_detect(colnames(children), "_code$"))] 
parent_coders <- colnames(parents)[which(str_detect(colnames(parents), "_code$"))] 
codes <- c("neutral", "positive", "uncodable", "neg_dys", "neg_angry", "gen_neg" ,"total")

#create empty dfs to percent agreements
all_summary_df <- data.frame(matrix(NA, nrow=(length(all_coders)+3), ncol=length(codes))) #+3 rows for kappa_allcoders, presence_agree_allcoders and percent_agree_allcoders
parent_summary_df <- data.frame(matrix(NA, nrow=(length(parent_coders)+3), ncol=length(codes)))
child_summary_df <- data.frame(matrix(NA, nrow=(length(child_coders)+3), ncol=length(codes)))

#calculate base rates for each coder across all participants
for (j in 1:length(codes)){
  for (k in 1:length(all_coders)){
    if (codes[j] != "total") { #for all codes except total...
    #base rates for each coder and code
      coder_code_col <- str_c(codes[j], sub("_code", "", all_coders[k]), sep="_")
      all_summary_df[k, j] = sum(mega_df[[coder_code_col]], na.rm=T)/sum(!is.na(mega_df[[coder_code_col]]))
      rownames(all_summary_df)[k] <- paste0(str_c("baserate", sub("_code", "", all_coders[k]), sep="_"))
      colnames(all_summary_df)[j] <- paste0(codes[j])
    }
  }
}

#calcuate base rates for each coder across all parent files
for (j in 1:length(codes)){
  for (k in 1:length(parent_coders)){
    if (codes[j] != "total") { #for all codes except total...
    #base rates for each coder and code
      coder_code_col <- str_c(codes[j], sub("_code", "", parent_coders[k]), sep="_")
      parent_summary_df[k, j] = sum(parents[[coder_code_col]], na.rm=T)/sum(!is.na(parents[[coder_code_col]]))
      rownames(parent_summary_df)[k] <- paste0(str_c("baserate", sub("_code", "", parent_coders[k]), sep="_"))
      colnames(parent_summary_df)[j] <- paste0(codes[j])
    }
  }
}

#calcuate base rates for each coder across all child files
for (j in 1:length(codes)){
  for (k in 1:length(child_coders)){
    if (codes[j] != "total") { #for all codes except total...
    #base rates for each coder and co
      coder_code_col <- str_c(codes[j], sub("_code", "", child_coders[k]), sep="_")
      child_summary_df[k, j] = sum(children[[coder_code_col]], na.rm=T)/sum(!is.na(children[[coder_code_col]]))
      rownames(child_summary_df)[k] <- paste0(str_c("baserate", sub("_code", "", child_coders[k]), sep="_"))
      colnames(child_summary_df)[j] <- paste0(codes[j])
    }
  }
}

#rename first column 
#all_summary_df <- rownames_to_column(all_summary_df, var = "statistic")
#rename extra column for 'total' that will get filled in later
colnames(all_summary_df)[7] <- paste0(codes[7])
colnames(parent_summary_df)[7] <- paste0(codes[7])
colnames(child_summary_df)[7] <- paste0(codes[7])

#for parent and child summaries, calculate average base rate for each code
parent_summary_df[length(parent_coders)+1, ] <- colMeans(parent_summary_df, na.rm=TRUE)
child_summary_df[length(child_coders)+1, ] <- colMeans(child_summary_df, na.rm=TRUE)

rownames(parent_summary_df)[length(parent_coders)+1] <- "averge_base_rate"
rownames(child_summary_df)[length(child_coders)+1] <- "averge_base_rate"
```

# Create summary child and parent files with 1 row per participant
Child summary and parent summary
MBB_2_111_child kappa_code1 kappa_code2 .... perc_agree_code1.... presence_agree_code1 ... 
each code will have kappa, perc_agree, presence_agree, base_rate_coder1, base_rate_coder2
neutral (#1) will be neutral_perc_agree (1), neutral_presence_agree (2), neutral_kappa (3), base_rate_coder1 (4), case_rate_coder2 (5)
positive (#2) will be positve_perc_agree (6), positive_presence_agree (7), positive_kappa (8), 9, 10
uncodable (#3) will be 11, 12, 13, 14, 15
```{r}
#subset merged_dfs into child dfs and parent dfs
child_dfs <- merged_dfs[grepl("child",names(merged_dfs))]
parent_dfs <- merged_dfs[grepl("parent",names(merged_dfs))]

calc_reliability_each_p_1row <- function(child_dfs) {
  codes <- c("neutral", "positive", "uncodable", "neg_dys", "neg_angry", "gen_neg","total")
  #create parent and child dfs with 1 row for each participant
  child_summary_df_1row <-  data.frame(matrix(NA, nrow=length(child_dfs), ncol=(((length(codes)-1)*5)+6)))
  #parent_summary_df_1row <- data.frame(matrix(NA, nrow=length(parent_dfs), ncol=(length(codes)*3)-1))
  
  #fill in the child df... 
  for (i in 1:length(child_dfs)) {
    #get list of coder columns and codes
    coders <- colnames(child_dfs[[names(child_dfs)[i]]])[which(str_detect(colnames(child_dfs[[names(child_dfs)[i]]]), "_code$"))] 
    
    #calculate reliability metrics (percent agreement, kappas, and base rates) put in df
    for (j in 1:length(codes)){
        if (codes[j] != "total") { #for all codes except total...
          coder1_col_name = str_c(codes[j], sub("_code", "", coders[1]), sep="_") #coder1 dummy code column name e.g., neutral_MA
          coder2_col_name = str_c(codes[j], sub("_code", "", coders[2]), sep="_") #coder2 dummy code column name neutral_CB
          #percent agreement (column numbers are 1, 4, 7, etc. )
          child_summary_df_1row[i, (1+((j-1)*5))] = (sum(apply(child_dfs[[i]][,startsWith(colnames(child_dfs[[i]]), codes[j])]==1, 1, all)) + sum(apply(child_dfs[[i]][,startsWith(colnames(child_dfs[[i]]), codes[j])]==0, 1, all)))/sum(apply(!is.na(child_dfs[[i]][,startsWith(colnames(child_dfs[[i]]), codes[j])]), 1, all))
          colnames(child_summary_df_1row)[(1+((j-1)*5))] <- paste0(str_c(codes[j], "_percent_agree", sep="")) #
          rownames(child_summary_df_1row)[i] <- names(child_dfs[i]) #
            
          #presence agreement (column numbers are 2, 5, 8, etc.)
          child_summary_df_1row[i, (2 + (5*(j-1)))] = (sum(apply(child_dfs[[i]][,startsWith(colnames(child_dfs[[i]]), codes[j])]==1, 1, all)))/sum(child_dfs[[i]][, coder1_col_name] == 1 | child_dfs[[i]][, coder2_col_name] == 1, na.rm=T) #total number of times both cols are 1 divided by nrows with any instances of that code
          colnames(child_summary_df_1row)[(2 + (5*(j-1)))] <- paste0(str_c(codes[j], "_prescence_agree", sep="")) #
          rownames(child_summary_df_1row)[i] <- names(child_dfs[i]) #
          
          #kappas (column numbers are 3, 6, 9, 12, etc)
          child_summary_df_1row[i, (3 + (5*(j-1)))] = kappa2(cbind(child_dfs[[i]][[coder1_col_name]], child_dfs[[i]][[coder2_col_name]]))$value
          colnames(child_summary_df_1row)[(3 + (5*(j-1)))] <- paste0(str_c(codes[j], "_kappa", sep=""))
          rownames(child_summary_df_1row)[i] <- names(child_dfs[i]) #
          
          #base rates for each coder and code
          child_summary_df_1row[i, (4 + (5*(j-1)))] = sum(child_dfs[[i]][[coder1_col_name]], na.rm=T)/sum(!is.na(child_dfs[[i]][[coder1_col_name]]))
          colnames(child_summary_df_1row)[(4 + (5*(j-1)))] <- paste0(str_c("baserate", codes[j], "coder1", sep="_"))
          child_summary_df_1row[i, (5*(j))] = sum(child_dfs[[i]][[coder2_col_name]], na.rm=T)/sum(!is.na(child_dfs[[i]][[coder2_col_name]]))
          colnames(child_summary_df_1row)[(5*(j))] <- paste0(str_c("baserate", codes[j], "coder2", sep="_"))
          }
     
        else { #do a different procedure for total
          #percent agreement
          overall_agree_col <- "coders_agree"
          child_summary_df_1row[i, 31] = sum(child_dfs[[i]][[overall_agree_col]], na.rm=T)/sum(!is.na(child_dfs[[i]][[overall_agree_col]]))
          colnames(child_summary_df_1row)[31] <- paste0(str_c(codes[j], "_percent_agree", sep=""))
          rownames(child_summary_df_1row)[i] <- names(child_dfs[i])
          
          #total kappa
          child_summary_df_1row[i , 32] <- kappa2(cbind(child_dfs[[i]][[coders[1]]], child_dfs[[i]][[coders[2]]]))$value #calculate total kappa, add new variable 
          colnames(child_summary_df_1row)[32] <- paste0(str_c(codes[j], "_kappa", sep=""))
          rownames(child_summary_df_1row)[i] <- names(child_dfs[i])
        }
    }
    #add columns for number of seconds coded by each coder
    child_summary_df_1row[i, 33] = sum(!is.na(child_dfs[[i]][[coders[1]]]))
    colnames(child_summary_df_1row)[33] <- "seconds_coded_coder1"
    child_summary_df_1row[i, 34] = sum(!is.na(child_dfs[[i]][[coders[1]]]))
    colnames(child_summary_df_1row)[34] <- "seconds_coded_coder2" 
    
    #add columns for who is coder 1 and coder2
    child_summary_df_1row[i, 35] = paste0(sub("_code", "", coders[1]))
    colnames(child_summary_df_1row)[35] <- "coder1"
    child_summary_df_1row[i, 36] = paste0(sub("_code", "", coders[2]))
    colnames(child_summary_df_1row)[36] <- "coder2" 
  }
  #create 'coder' first column
  child_summary_df_1row <- rownames_to_column(child_summary_df_1row, var = "participant")
  df <-  child_summary_df_1row 
  if (any(grepl("child", child_summary_df_1row$participant))) {
    df_name <- "child_summary_df_1row"} 
  else {
    df_name <- "parent_summary_df_1row"}
  #assign the completed list to the global environment
  assign(df_name, df, envir=.GlobalEnv)
}

#apply the function
calc_reliability_each_p_1row(child_dfs) 
calc_reliability_each_p_1row(parent_dfs)

```

## Add average of dyad-specific kappas to the individual dyad parent and child summary files
```{r}
#new row in each file which is called "average_of_all_dyads" which is just the colMeans for each column (NAs removed)

#calculate colmeans
child_mean_no_na <- colMeans(child_summary_df_1row[, !(colnames(child_summary_df_1row) %in% c("participant", "coder1", "coder2"))], na.rm = TRUE)
child_mean_row <- as.data.frame(t(child_mean_no_na))

parent_mean_no_na <- colMeans(parent_summary_df_1row[, !(colnames(parent_summary_df_1row) %in% c("participant", "coder1", "coder2"))], na.rm = TRUE)
parent_mean_row <- as.data.frame(t(parent_mean_no_na))

#manipulate colmeans so that they have the same columns as the rest of the summary 1row dfs
child_mean_row <- child_mean_row %>% 
  mutate(
    participant = "average_of_all_dyads"
  ) %>% 
  dplyr::select(
    participant, everything()
  ) %>% 
  dplyr::mutate(
    coder1 = NA,
    coder2 = NA
  )

parent_mean_row <- parent_mean_row %>% 
  mutate(
    participant = "average_of_all_dyads"
  ) %>% 
  dplyr::select(
    participant, everything()
  ) %>% 
  dplyr::mutate(
    coder1 = NA,
    coder2 = NA
  )

child_summary_df_1row_final <- rbind(child_summary_df_1row, child_mean_row)
parent_summary_df_1row_final <- rbind(parent_summary_df_1row, parent_mean_row)
```

## Write child and parent summaries (1 row per participant)
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_reliability_data/" 

#write the summary file csv
write_csv(child_summary_df_1row_final, str_c(path, "child_summary_each_p.csv"))
write_csv(parent_summary_df_1row_final, str_c(path, "parent_summary_each_p.csv"))
```

### Calculate overall percent agreement and kappa for parent_summary and child_summary (NOT DONE W THIS)
MBB_2_111_child kappa_code1 kappa_code2 .... perc_agree_code1.... presence_agree_code1 ... 
overall
```{r}
#get list of coder pairs
coderpairs <- names(coder_dfs)
child_coders <- colnames(children)[which(str_detect(colnames(children), "_code$"))] 
parent_coders <- colnames(parents)[which(str_detect(colnames(parents), "_code$"))] 
child_coderpairs <- coderpairs[which(grepl(substr(child_coders,1, 3), substr(coderpairs, 1, 5)
))]

string_matching <- function(list1, list2) {
  # Initialize an empty vector to store matching strings
  matching_strings <- c()
  # Iterate through each string in list1 (coderpairs)
  for (string1 in list1) {
    # Iterate through each string in list2 (child coders)
    for (string2 in list2) {
      # Check if string2 is a substring of string1
      if (grepl(string2, string1)) {
        # Append string1 to the matching_strings vector
        matching_strings <- c(matching_strings, string2)
        break  # Break out of the inner loop once a match is found
      }
    }
  }
  # Return the vector of matching strings
  return(matching_strings)
}

child_coderpairs <- string_matching(coderpairs, child_coders)
parent_coderpairs <- string_matching(coderpairs, parent_coders)
print(parent_coderpairs)

#extract coder1 and coder2 from each df based on pair
extract_coders <- function(coderpairs, coder_num) {
  coderx <- c()
  for (i in 1:length(coderpairs)) {
    coderx <- c(coderx, strsplit(coderpairs[i], "[_]")[[1]][coder_num])
  }
  return(coderx)
}

child_coder1 <- str_c(extract_coders(child_coderpairs, 1), "_code", sep="") 
child_coder2 <- str_c(extract_coders(child_coderpairs, 2), "_code", sep="") 
parent_coder1 <- str_c(extract_coders(parent_coderpairs, 1), "_code", sep="")
parent_coder2 <- str_c(extract_coders(parent_coderpairs, 2), "_code", sep="")


#percent agreement for each code: recode all coders into coder1, coder2 (will work if only 2 coders coded each person)
children <- children %>%
  mutate(coder1 = ifelse(rowSums(!is.na(across(all_of(child_coder1)))) > 0,
                          coalesce(!!!rlang::syms(child_coder1)),
                          NA),
         coder2 = ifelse(rowSums(!is.na(across(all_of(child_coder2)))) > 0,
                          coalesce(!!!rlang::syms(child_coder2)),
                          NA)) 
parents <- parents %>%
  mutate(coder1 = ifelse(rowSums(!is.na(across(all_of(parent_coder1)))) > 0,
                          coalesce(!!!rlang::syms(parent_coder1)),
                          NA),
         coder2 = ifelse(rowSums(!is.na(across(all_of(parent_coder2)))) > 0,
                          coalesce(!!!rlang::syms(parent_coder2)),
                          NA)) 

#total percent agreement: sum of coders_agree/total nrow coders_agree
```

## Calculate reliability metrics for each pair of coders, total and for each code
```{r}
calc_reliability_coderpair <- function(coder_dfs) {
  list_name <- "coderpair_sum_dfs"
  list <- list()
  for (i in 1:length(coder_dfs)) {
    #create the final df name
    final_df_name <- str_c(sub("_codes", "", names(coder_dfs)[i]), "_coderpair", sep="")
    
    #get list of coder columns and codes
    coders <- colnames(coder_dfs[[names(coder_dfs)[i]]])[which(str_detect(colnames(coder_dfs[[names(coder_dfs)[i]]]), "_code$"))] 
    codes <- c("neutral", "positive", "uncodable", "neg_dys", "neg_angry", "gen_neg", "total")
    
    #create empty dfs to percent agreements
    coderpair_summary_df <- data.frame(matrix(NA, nrow=5, ncol=length(codes))) #rows will be "perc_agree", "presence_agree", "kappa", "baserate_c1", "baserate_c2"
    #columns will be code1, code2, etc 
    
    #calculate reliability metrics (percent agreement, kappas, and base rates) put in df
    for (j in 1:length(codes)){
        if (codes[j] != "total") { #for all codes except total...
          coder1_col_name = str_c(codes[j], sub("_code", "", coders[1]), sep="_") #coder1 dummy code column name e.g., neutral_MA
          coder2_col_name = str_c(codes[j], sub("_code", "", coders[2]), sep="_") #coder2 dummy code column name neutral_CB
          #percent agreement
          coderpair_summary_df[1, j] = (sum(apply(coder_dfs[[i]][,startsWith(colnames(coder_dfs[[i]]), codes[j])]==1, 1, all)) + sum(apply(coder_dfs[[i]][,startsWith(colnames(coder_dfs[[i]]), codes[j])]==0, 1, all)))/sum(apply(!is.na(coder_dfs[[i]][,startsWith(colnames(coder_dfs[[i]]), codes[j])]), 1, all))
          colnames(coderpair_summary_df)[j] <- paste0(codes[j]) #name the column "neutral"
          rownames(coderpair_summary_df)[1] <- paste0(str_c("percent_agree", sub("_code", "", coders[1]), sub("_code", "", coders[2]), sep="_")) #name the row "MA_code_agree"
          
          #presence agreement
          coderpair_summary_df[2, j] = (sum(apply(coder_dfs[[i]][,startsWith(colnames(coder_dfs[[i]]), codes[j])]==1, 1, all)))/sum(coder_dfs[[i]][, coder1_col_name] == 1 | coder_dfs[[i]][, coder2_col_name] == 1, na.rm=T) #total number of times both cols are 1 divided by nrows with any instances of that code
          colnames(coderpair_summary_df)[j] <- paste0(codes[j]) #name the column "neutral"
          rownames(coderpair_summary_df)[2] <- paste0(str_c("presence_agree", sub("_code", "", coders[1]), sub("_code", "", coders[2]), sep="_"))
          
          #kappas
          coderpair_summary_df[3, j] = kappa2(cbind(coder_dfs[[i]][[coder1_col_name]], coder_dfs[[i]][[coder2_col_name]]))$value
          colnames(coderpair_summary_df)[j] <- paste0(codes[j])
          rownames(coderpair_summary_df)[3] <- paste0(str_c("kappa", sub("_code", "", coders[1]), sub("_code", "", coders[2]), sep="_"))
     
          #base rates for each coder and code
          coderpair_summary_df[4, j] = sum(coder_dfs[[i]][[coder1_col_name]], na.rm=T)/sum(!is.na(coder_dfs[[i]][[coder1_col_name]]))
          rownames(coderpair_summary_df)[4] <- paste0(str_c("baserate_", sub("_code", "", coders[1]), "_w", sub("_code", "", coders[2]), sep=""))
          coderpair_summary_df[5, j] = sum(coder_dfs[[i]][[coder2_col_name]], na.rm=T)/sum(!is.na(coder_dfs[[i]][[coder2_col_name]]))
          rownames(coderpair_summary_df)[5] <- paste0(str_c("baserate_", sub("_code", "", coders[2]), "_w", sub("_code", "", coders[1]),sep=""))
          }
        else { #do a different procedure for total
          #percent agreement
          overall_agree_col <- "coders_agree"
          coderpair_summary_df[1, j] = sum(coder_dfs[[i]][[overall_agree_col]], na.rm=T)/sum(!is.na(coder_dfs[[i]][[overall_agree_col]]))
          colnames(coderpair_summary_df)[j] <- paste0(codes[j])
          rownames(coderpair_summary_df)[1] <- paste0(str_c("percent_agree", sub("_code", "", coders[1]), sub("_code", "", coders[2]), sep="_"))
          
          #total kappa
          coderpair_summary_df[3 , j] <- kappa2(cbind(coder_dfs[[i]][[coders[1]]], coder_dfs[[i]][[coders[2]]]))$value #calculate total kappa, add new variable 
          colnames(coderpair_summary_df)[j] <- paste0(codes[j])
          rownames(coderpair_summary_df)[3] <- paste0(str_c("kappa", sub("_code", "", coders[1]), sub("_code", "", coders[2]), sep="_"))
        }
      }
    #create 'coder' first column
    coderpair_summary_df <- rownames_to_column(coderpair_summary_df, var = "statistic")
    list[[i]] <-  coderpair_summary_df 
    names(list)[i] <- final_df_name
  }
  #assign the completed list to the global environment
  assign(list_name, list, envir=.GlobalEnv)
}

#apply the function
calc_reliability_coderpair(coder_dfs) 

#combine the list of dfs into one
coderpairs_summary <- bind_rows(coderpair_sum_dfs)
```

### Calculate reliability across all coders and participants
NOTE: cannot calculate all kappa the same as for the certification script becuase we have a bunch of coder pairs rather than a bunch of coders compared against consensus codes
```{r}
#calculate reliability
for (j in 1:length(codes)){
  #kappa_allcoders for each code can be calculated as the average kappa across all coder pairs
  all_summary_df[length(all_coders)+1, j] = mean(coderpairs_summary[grepl("kappa", coderpairs_summary$statistic), j+1])
  rownames(all_summary_df)[length(all_coders)+1] = "kappa_allcoders"
  
  #percent agreement as average of percent agreement across all coder pairs
  all_summary_df[length(all_coders)+2, j] = mean(coderpairs_summary[grepl("percent", coderpairs_summary$statistic), j+1])
  rownames(all_summary_df)[length(all_coders)+2] = "percent_agree_allcoders"
  
  #presence agreement as average of presence agreement across all coder pairs
  all_summary_df[length(all_coders)+3, j] = mean(coderpairs_summary[grepl("presence", coderpairs_summary$statistic), j+1])
  rownames(all_summary_df)[length(all_coders)+3] = "presence_agree_allcoders"
}

all_summary_df <- rownames_to_column(all_summary_df, var = "statistic")
```

## Combine all of the summary across all participants statistics into one df
```{r}
final_summary <- coderpairs_summary %>% bind_rows(all_summary_df)
```

## Write final summary file
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_reliability_data/" 

#write the summary file csv
write_csv(final_summary, str_c(path, "all_summary.csv"))
```

# Calculate number of participants for each coder pair and across all coder pairs
```{r}
#add number of participants in each coder pair
calc_num_participants <- function(coder_dfs) {
  numps_summary_df <- data.frame(matrix(NA, nrow=(length(coder_dfs)+1), ncol=1))
  for (i in 1:length(coder_dfs)) {
    numps_summary_df[i,1] = length(unique(coder_dfs[[i]]$participant_id))
    rownames(numps_summary_df)[i] <- paste0(names(coder_dfs[i]))
  }
  colnames(numps_summary_df) <- "number_participants"
  assign("n_ps_summary", numps_summary_df, envir=.GlobalEnv)
}

calc_num_participants(coder_dfs)

#add number of participants across all coder pairs
n_ps_summary[length(coder_dfs)+1, 1] <- length(unique(mega_df$participant_id))
rownames(n_ps_summary)[length(coder_dfs)+1] <- "all_coders"
n_ps_summary <- rownames_to_column(n_ps_summary, var = "coderpair")
```

## Write number of participants file
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_reliability_data/" 

#write the summary file csv
write_csv(n_ps_summary, str_c(path, "number_participants.csv"))
```

