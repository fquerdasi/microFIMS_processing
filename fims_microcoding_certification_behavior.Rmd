---
title: "fims_microcoding_certification_behavior"
author: "Fran Querdasi"
date: "2023-01-20"
output: html_document
---
This script takes coder .txt files and consensus codes for microFIMS affect coding, and provides 3 outputs:
1) "_agree" files: A set of .csv files (1 for each participant and parent/child combo) with dummy codes capturing whether each coder agreed (1) or disagreed (0) with the consensus code for that second. This file also has a relative time variable that indexes time (rounded to nearest integer) from start of the task. 
2) "_summary" files: A set of .csv files (1 for each participant and parent/child combo) with the % agreement and kappa values for each coder, total across all codes and per code.
3) "all_summary" file: A .csv file with % agreement and kappa values for each coder, total across all codes and per code, across all participants that they rated. 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Setup
## Load libraries
```{r}
suppressPackageStartupMessages({
  library(stringr)
  library(stringi)
  library(readxl) 
  library(purrr)
  library(lubridate)
  library(irr) #for cohen's kappa
  source("fims_microcoding_helper_functions.R")
  library(reshape2)
  library(tidyverse)
})
```

## Archive any old files from the prior week into a new folder called the date that the all_summary file was last modified
Running the rest of the script will otherwise overrwrite the files that are loose in the behavior_certification directory
```{r}
# default folder name will be the date that the all_summary file was generated; need to manually specify other folder name if you want 
output_path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_cerfication_data/microFIMS_certification_behavior"

summary_file <- list.files(path=output_path, pattern="all_summary", recursive=FALSE, full.names=TRUE)

mod_time <- file.info(summary_file)$ctime
mod_date <- gsub(" .*$", "", mod_time) # a space, then any char (.) any number of times (*) until end of string ($)

if (length(mod_time) != 0) { # if there are in fact files loose in the main folder

  # create the directory for old files
  dir.create(str_c(output_path, "/", mod_date, sep=""))
  
  # get a list of all files in main behavior folder
  beh_output <- list.files(output_path, pattern=".csv")
  
  # move all of the files currently in the main behavior folder to the new directory
  file.copy(from=file.path(output_path, beh_output), to=str_c(output_path, "/", mod_date, sep=""))
  
  # remove all of the files from the main directory that you just copied
  file.remove(file.path(output_path, beh_output))
}
```


## Load data
For certification, during Spring 2023 behavior will be certified. 
```{r}
#get paths
consensus_codes <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/MicroFIMS expert behavior codes.xlsx"

coders_codes <- "../../../../Lab/Video_coding/FIMS_Micro/" #overall directory where all of the codes to be certified live

#load data
multiplesheets(consensus_codes, "cons_codes") #load the consensus codes as a list of dfs, each df is a id_parent or _child

#get all of the .txt files from within the overall directory
dirs = list.dirs(coders_codes)
dirs_use = grep('fims_micro_behavior', dirs, value = TRUE)
fl <- list.files(path=dirs_use, pattern = "*.txt", recursive=TRUE, full.names = TRUE) #this will output a list of the files

#get a list of empty files from df to exclude for reading in (otherwise r with throw an error)
empty <- fl[file.size(fl) == 0L]

#read in all the coder files
read_coder_files <- function(fl) {
list_name <- "coder_dfs"
list <- list()
for (i in 1:length(fl)) { #for each file in the list
  #if file and folder name match, and the file is not empty...
  if ((str_match(fl[[i]], "Micro//(.*?)/fims")[2] == str_match(fl[[i]], "behavior/(.*?)_[A-Za-z]")[2]) & !(fl[[i]] %in% empty)) {
    #get info to add to the dfs
    id_file_name <- str_match(fl[[i]], "behavior/(.*?)_[A-Za-z]")[2] #this is the participant id
    coder_initials <- gsub(".*?_([A-Za-z]{2})(?=\\.|_|$).*", "\\1", fl[[i]], perl = TRUE) #extract two letters bounded by _ on left and either _ or . on right
    #read the file into r, create column names
    df <- read.table(fl[[i]], header=FALSE, fill=TRUE, sep="\t")
    colnames(df) <- c("Tier", "Participant", "Time", str_c(coder_initials, "_code")) #column names are Tier, Participant, Time, and <coder initials>_code
    #set the df name to match the participant: <id_file_name>_<child|parent>
    df_name <- str_c(id_file_name, "_", tolower(df$Participant[1]), "_", coder_initials) #need to add coder initials so that they're not all the same name
    #assign df to the list
    list[[i]] <- df 
    names(list)[i] <- df_name
  } else if (fl[[i]] %in% empty) { #else if the file is empty...
    #write a message telling the person that the file name is empty and not being read in
    print(paste0(str_match(fl[[i]], 'behavior/(.*)')[2], " is empty -- not being read into R"))
  } else { #if the file and folder name do not match...
    #write a message saying to check naming
    print(paste0("file ", str_match(fl[[i]], 'behavior/(.*)')[2], " and folder ", str_match(fl[[i]], "Micro//(.*?)/fims")[2], " names do not match, not being read into R now -- please check"))
  }
}
#assign the list to the global environment
assign(list_name, list, envir=.GlobalEnv)
}

#apply the function
read_coder_files(fl)
```

# Take only the most recently modified versions of each coder/participant
Note: still working on this part, so commented out for now
```{r}
# test <- data.frame("df_names" = names(coder_dfs), "mtime" = file.info(fl)$mtime)
# 
# unique_files <- test %>% 
#   group_by(df_names) %>% 
#   slice(which.max(mtime))
# 
# for (i in 1:length(coder_dfs)) {
#   if (names(coder_dfs)[i] == names(coder_dfs)[i-1]) { #if two coder df names are the same...
# 
#   }
```


# Change all codes to be  lowercase
```{r}
#remove the null and na entries in the list (from files that were not read in)
# coder_dfs = coder_dfs[-which(sapply(coder_dfs, is.null))]
# coder_dfs = coder_dfs[-which(sapply(names(coder_dfs), is.na))]

# coder codes
for (df_name in names(coder_dfs)) {
  coder_dfs[[df_name]] <- mutate(coder_dfs[[df_name]], across(contains("_code"), ~str_to_lower(.), .names="{col}"))
}

# consensus codes
for (df_name in names(cons_codes)) {
  cons_codes[[df_name]] <- mutate(cons_codes[[df_name]], `Consensus Code` = str_to_lower(`Consensus Code`))
}
```


# Merge the consensus codes with the coders' codes into the same df
NOTE: if you run the for function more than once, will get weird errors
```{r}
#change the time variable to be double in all dfs
for (i in 1:length(coder_dfs)) {
  if (is.character(coder_dfs[[i]]$Time)) { #if the time variable is a character...
    coder_dfs[[i]]$Time <- as.numeric(lubridate::hms(coder_dfs[[i]]$Time)) #convert it to hh:mm:ss and then to numeric
  }
}

#get the names of all the dataframes
cons_df_names <- names(cons_codes) #names of consensus code dfs
mbb_cons_df_names <- cons_df_names[str_detect(cons_df_names, "MBB")] #remove any df names that are not used
coder_df_names <- names(coder_dfs) #names of the coder dfs

#for all of the names_of_dfs, if cons_df_names contains the name, then full_join it with the df that contains it on Tier and Time
join_coder_consensus_dfs <- function(coder_dfs, cons_codes, coder_df_names, mbb_cons_df_names) {
list_name <- "merged_dfs" #set the name of the output list
list <- list() #initialize an empty list to fill below
for (i in 1:length(mbb_cons_df_names)) { #for all of the consensus code sheet names
  for (j in 1:length(coder_df_names)) { #for all of the coder dfs
    #if the name of the consensus code sheet (e.g., MBB_2_074_parent) is contained in the coder df name (which should be MBB_2_074_parent_<coder initials>)
    if (suppressWarnings(str_detect(coder_df_names[j], stringr::regex(mbb_cons_df_names[i], ignore.case=T)))) {
      #assign the name of the df to be the consensus code name
      df_name <- mbb_cons_df_names[i]
      if (!exists(df_name)) { #if the df has not already been made...
      df1 <- cons_codes[[i]] %>% dplyr::left_join(coder_dfs[[j]], by = c("Tier", "Participant", "Time")) #left join the coder df to the consensus code df (all columns are same except for the coder code, <coder initiails>_code)
      list[[i]] <- assign(df_name, df1, envir=.GlobalEnv) #assign the df to the global environment (need to do for this loop so that next time it runs can tell if it was made already or not)
      names(list)[i] <- df_name #name the df
    }
     else { #if it has been made already...
      df1 <- df1 %>% dplyr::left_join(coder_dfs[[j]], by = c("Tier", "Participant", "Time")) #left join the next coder name to the df that was made above
      list[[i]] <- assign(df_name, df1, envir=.GlobalEnv) #assign to the global envir
      names(list)[i] <- df_name
     } 
    }
  }
}
#assign the completed list to the global environment
assign(list_name, list, envir=.GlobalEnv)
}

#apply the function
join_coder_consensus_dfs(coder_dfs, cons_codes, coder_df_names, mbb_cons_df_names)
```

# Create the individual second agreement/disagreement files
(1 for each participant_child/parent file) 
AO_agree
MB_agree etc
```{r}
#remove the null entries in the list (from files that were not read in)
merged_dfs = merged_dfs[-which(sapply(merged_dfs, is.null))]

# change codes to all lower case
for (i in 1:length(merged_dfs)) {
  colnames(merged_dfs[[i]])[which(str_detect(colnames(merged_dfs[[i]]), "[A-Z]_code$"))]
}

#make all the consensus code variables character (they will automatically be, but to avoid the loop below from erroring when some are not filled in currently)
for (i in 1:length(merged_dfs)) {
  if (is.logical(merged_dfs[[i]]$`Consensus Code`)) { #if the time variable is a character...
    merged_dfs[[i]]$`Consensus Code` <- as.character(merged_dfs[[i]]$`Consensus Code`) #convert it to hh:mm:ss and then to numeric
  }
}

#create the variables (relative time, binary agree for each code and coder)
# codes are: "neutral behavior", "active social engagement behavior", "positive social communication behavior", "withdrawal from interaction", "off-task behavior", "uncodable", "non-autonomous behavior", and "rejecting others" 
for (df_name in names(merged_dfs)) {
    merged_dfs[[df_name]] <- mutate(merged_dfs[[df_name]], across(contains("_code"), ~case_when(
      #if the string is found in the coder code and consensus code, variable is 1
      grepl("neutral", ., ignore.case=TRUE) & grepl("neutral", `Consensus Code`, ignore.case=TRUE) ~ 1, 
      grepl("active", ., ignore.case=TRUE) & grepl("active", `Consensus Code`, ignore.case=TRUE) ~ 1,
      grepl("positive", ., ignore.case=TRUE) & grepl("positive", `Consensus Code`, ignore.case=TRUE) ~ 1,
      grepl("withdraw", ., ignore.case=TRUE) & grepl("withdraw", `Consensus Code`, ignore.case=TRUE) ~ 1,
      grepl("off", ., ignore.case=TRUE) & grepl("off", `Consensus Code`, ignore.case=TRUE) ~ 1,
      grepl("uncodable", ., ignore.case=TRUE) & grepl("uncodable", `Consensus Code`, ignore.case=TRUE) ~ 1,
      grepl("auto", ., ignore.case=TRUE) & grepl("auto", `Consensus Code`, ignore.case=TRUE) ~ 1,
      grepl("reject", ., ignore.case=TRUE) & grepl("reject", `Consensus Code`, ignore.case=TRUE) ~ 1,
      is.na(.) | is.na(`Consensus Code`) ~ NA_real_,  #if there is NA in either consensus code or coder code, value is NA
      TRUE ~ 0 #otherwise if none of the above are met, value is 0
  ), .names = "{col}_agree"), #variable names are <coder initials>_code_agree
  relative_time = round(Time - Time[1], digits=0)) #relative time is Time minus initial time, rounded to nearest integer
  
  #select from the merged dfs only the columns we care about   
  merged_dfs[[df_name]] <- dplyr::select(merged_dfs[[df_name]],
                                           Tier,
                                           Participant,
                                           Time,
                                           `Consensus Code`,
                                           contains("_code"),
                                           relative_time)
}

```

## Write individual participant files with binary agreement per code
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_cerfication_data/microFIMS_certification_behavior/" #path to write the files

#for each entry in the merged_dfs list, write the entry as a .csv called "name_agreement.csv"
lapply(1:length(merged_dfs), function(i) write.csv(merged_dfs[[i]], 
                                      file = paste0(str_c(path, names(merged_dfs)[i], "_agreement.csv", sep="")),
                                      row.names = FALSE))

#NULLs output below mean that writing the file was successful 
```

# Create summary file for participant 
## Calculate % agreement 
AO_total%, AO_neutral%, AO_warm%, etc. for each coder
Calculate cohen's kappa between coder and consensus codes
```{r}
#save total % agreement and by code into a list of dfs: 'perc_agree_dfs" (1 df per participant)
create_agreement_dfs <- function(merged_dfs) {
  list_name <- "perc_agree_dfs"
  list <- list()
  for (i in 1:length(merged_dfs)) {
    #create the final df name
    final_df_name <- str_c(names(merged_dfs)[i], "_%agree", sep="")
    
    #make the df with total % agreement across all codes
    total_df <- as.data.frame(colSums(merged_dfs[[i]] %>% dplyr::select(contains("_agree")), na.rm=TRUE)/colSums(!is.na(merged_dfs[[i]] %>% dplyr::select(contains("_agree"))))) #total of 1s in the coder agree column that are not NA divided by non-na rows
    colnames(total_df) <- c("total_%agree") #name % agree column
    total_df <- rownames_to_column(total_df, var = "coder") #name first coder column
    
    #create consolidated consensus code columns to account for small differences in consensus code entries #codes are: "neutral behavior", "active social engagement behavior", "positive social communication behavior", "withdrawal from interaction", "off-task behavior", "uncodable", "non-autonomous behavior", and "rejecting others"
    merged_dfs[[i]] <- mutate(merged_dfs[[i]], cons_codes_consol = case_when(
        grepl("neutral", `Consensus Code`, ignore.case=T) ~ "neutral behavior",
        grepl("active", `Consensus Code`, ignore.case=T) ~ "active social engagement behavior",
        grepl("positive", `Consensus Code`, ignore.case=T) ~ "positive social communication behavior",
        grepl("withdraw", `Consensus Code`, ignore.case=T) ~ "withdrawal from interaction",
        grepl("off",  `Consensus Code`, ignore.case=T) ~ "off-task behavior",
        grepl("uncodable", `Consensus Code`, ignore.case=T) ~ "uncodable",
        grepl("auto", `Consensus Code`, ignore.case=T) ~ "non-autonomous behavior",
        grepl("reject", `Consensus Code`, ignore.case=T) ~ "rejecting others"
      ))

      #calculate percent agreement by code
      code_df <- merged_dfs[[i]] %>% 
            group_by(cons_codes_consol) %>% #collect entries relevant to each of the cons_code_consol values
            summarise(across(contains("_agree"), ~sum(., na.rm=T)/sum(!is.na(.)), .names="{col}")) %>% #for each coder's "_agree" variable, sum their entries and divide by the tally of entries for that consens_codes_consol code where the coder's _agree variable is not NA
            as.data.frame()
      #change the columns
      #remove the NA column for NA values of cons_codes_consol
      code_df <- filter(code_df, !is.na(cons_codes_consol))
      # first remember the new column names and coder names
      names <- str_c(code_df$cons_codes_consol, "%agree", sep="_")
      coders_code_df <- colnames(code_df)[-1]
      # transpose all but the first column (names)
      code_df_t <- as.data.frame(t(code_df[,-1]))
      #assign column names to the columns
      colnames(code_df_t) <- names 
      #label first column 
      code_df_t <- rownames_to_column(code_df_t, var = "coder")
      code_df_t[1] <- coders_code_df
    
      #merge these with total % agreement dataframe
      final_df <- total_df %>% left_join(code_df_t, by = "coder")
    
      #assign this to the list
      list[[i]] <- final_df 
      names(list)[i] <- final_df_name
  }
  #assign the completed list to the global environment
  assign(list_name, list, envir=.GlobalEnv)
}

#apply the function
create_agreement_dfs(merged_dfs) 

```

## Calculate kappas (total only) and base rates for each coder
```{r}
#create loop to go through all the merged_dfs and save the kappas in a list
create_kappa_baserates_dfs <- function(merged_dfs) {
  list_name_kappa <- "kappa_dfs"
  list_name_baserates <- "baserate_dfs"
  list_kappa <- list()
  list_baserates <- list()
  for (i in 1:length(merged_dfs)) {
    kappa_df_name <- str_c(names(merged_dfs)[i], "_kappas", sep="")
    baserate_df_name <- names(merged_dfs)[i]
    
    #create dummy code columns for each code for each coder's code and the consensus codes
    #"neutral behavior", "active social engagement behavior", "positive social communication behavior", "withdrawal from interaction", "off-task behavior", "uncodable", "non-autonomous behavior", and "rejecting others"
    merged_dfs[[names(merged_dfs)[i]]] <- mutate(merged_dfs[[names(merged_dfs)[i]]],
      across(contains("_code") & !contains("agree"), ~ifelse(grepl("neutral", ., ignore.case = TRUE), 1, 0), .names="neutral_{col}"),
      neutral_consens = ifelse(grepl("neutral", `Consensus Code`, ignore.case = TRUE), 1, 0),
      active_consens = ifelse(grepl("active", `Consensus Code`, ignore.case = TRUE), 1, 0),
      across(contains("_code") & !contains("agree") & !contains("neutral"), ~ifelse(grepl("active", ., ignore.case = TRUE), 1, 0), .names="active_{col}"),
      positive_consens = ifelse(grepl("positive", `Consensus Code`, ignore.case = TRUE), 1, 0),
      across(contains("_code") & !contains("agree") & !contains("neutral") & !contains("active"), ~ifelse(grepl("positive", ., ignore.case = TRUE), 1, 0), .names="positive_{col}"),
      uncodable_consens = ifelse(grepl("uncodable", `Consensus Code`, ignore.case = TRUE), 1, 0),
      across(contains("_code") & !contains("agree") & !contains("neutral") & !contains("active") & !contains("positive"), ~ifelse(grepl("uncodable", ., ignore.case = TRUE), 1, 0), .names="uncodable_{col}"),
      withdraw_consens = ifelse(grepl("withdraw", `Consensus Code`, ignore.case = TRUE), 1, 0),
      across(contains("_code") & !contains("agree") & !contains("neutral") & !contains("active") & !contains("positive") & !contains("uncodable"), ~ifelse(grepl("withdraw", ., ignore.case = TRUE), 1, 0), .names="withdraw_{col}"),
      offtask_consens = ifelse(grepl("off", `Consensus Code`, ignore.case = TRUE), 1, 0),
      across(contains("_code") & !contains("agree") & !contains("neutral") & !contains("active") & !contains("positive") & !contains("uncodable") & !contains("withdraw"), ~ifelse(grepl("off", ., ignore.case = TRUE), 1, 0), .names="offtask_{col}"),
      nonauto_consens = ifelse(grepl("auto", `Consensus Code`, ignore.case = TRUE), 1, 0),
      across(contains("_code") & !contains("agree") & !contains("neutral") & !contains("active") & !contains("positive") & !contains("uncodable") & !contains("withdraw") & !contains("offtask"), ~ifelse(grepl("auto", ., ignore.case = TRUE), 1, 0), .names="nonauto_{col}"),
      reject_consens = ifelse(grepl("reject", `Consensus Code`, ignore.case = TRUE), 1, 0),
      across(contains("_code") & !contains("agree") & !contains("neutral") & !contains("active") & !contains("positive") & !contains("uncodable") & !contains("withdraw") & !contains("offtask") & !contains("nonauto"), ~ifelse(grepl("reject", ., ignore.case = TRUE), 1, 0), .names="reject_{col}")
      )
    
    #get a list of coder initials and list of codes
    #select variables that end with code and have the first letter uppercase
    coders_init <- colnames(merged_dfs[[names(merged_dfs)[i]]])[which(str_detect(colnames(merged_dfs[[names(merged_dfs)[i]]]), "_code$") & stri_locate_first_regex(colnames(merged_dfs[[names(merged_dfs)[i]]]), "[A-Z]")==1)] 
    #remove NA values in coders (stri_locate_first_regex returns NA for columns that don't have any uppercase)
    coders <- coders_init[!is.na(coders_init)] 
    codes <- c("neutral", "active", "positive", "uncodable", "withdraw", "offtask", "nonauto", "reject", "total")
    
    #create empty dfs to hold the kappas and base rates
    kappas <- data.frame(matrix(NA, nrow=length(coders), ncol=1))
    base_rates_coders <- data.frame(matrix(NA, nrow=length(coders), ncol=length(codes))) 
    
    #calculate kappas and base rates for each coder and code, put in df
    for (j in 1:length(codes)){
      for (k in 1:length(coders)) {
        if (codes[j] != "total") { #for all codes except total...
          #calculate base rates for each coder and code
          code_rate_coder = str_c(codes[j], coders[k], sep="_")
          coder_codes = coders[k]
          base_rates_coders[k, j] = sum(merged_dfs[[i]][[code_rate_coder]], na.rm=T)/sum(!is.na(merged_dfs[[i]][[coder_codes]]))
          colnames(base_rates_coders)[j] <- str_c("baserate", codes[j], sep="_")
          rownames(base_rates_coders)[k] <- paste0(str_c(coders[k], "agree", sep="_"))
          }
        else { #do a different procedure for total
          coder_col_name = coders[k] #coder code variable
          cons_col_init_name = "Consensus Code" #consensus code
          # calculate total kappa
          kappas[k , 1] <- kappa2(cbind(merged_dfs[[i]][[cons_col_init_name]], merged_dfs[[i]][[coder_col_name]]))$value #calculate total kappa, add new variable 
          colnames(kappas)[1] <- paste0(str_c("kappa", "total", sep="_")) #name the column "Kappa_total"
          rownames(kappas)[k] <- paste0(str_c(coders[k], "agree", sep="_")) #name the row "MA_code_agree"
        }
      }
    }
    #create 'coder' first column
    kappas <- rownames_to_column(kappas, var = "coder")
    base_rates_coders <- rownames_to_column(base_rates_coders, var="coder")
    base_rates_coders <- dplyr::select(base_rates_coders, -X9)
    
    #calculate base rates for consensus codes, bind rows to the base_rate_coders df
    codes_minus_total <- codes[1:length(codes)-1] #get a list of codes except total 
    baserates_consens = data.frame(matrix(NA, nrow=1, ncol=length(codes_minus_total)))
    for (h in 1:length(codes_minus_total)){
      consens_code_col = str_c(codes_minus_total[h], "consens", sep="_")
      baserates_consens[1, h] = sum(merged_dfs[[i]][[consens_code_col]], na.rm=T)/sum(!is.na(merged_dfs[[i]][[consens_code_col]]))
      colnames(baserates_consens)[h] <- str_c("baserate", codes_minus_total[h], sep="_")
      rownames(baserates_consens)[1] <- "consensus_codes"
    }
    #merge the consensus codes base rates with the coders' base rates
    baserates_consens <- rownames_to_column(baserates_consens, var="coder")
    baserates_all <- base_rates_coders %>% bind_rows(baserates_consens)
    
    #assign the dfs to the lists
    list_kappa[[i]] <-  kappas 
    list_baserates[[i]] <- baserates_all
    names(list_kappa)[i] <- kappa_df_name
    names(list_baserates)[i] <- baserate_df_name
  }
  #assign the lists to the global environment
  assign(list_name_kappa, list_kappa, envir=.GlobalEnv)
  assign(list_name_baserates, list_baserates, envir=.GlobalEnv)
}

#apply the function
create_kappa_baserates_dfs(merged_dfs)

#NOTE: NAs mean that either consensus code or coder had no instances of the code
```

## Calculate total kappa across all coders for each participant
```{r}
create_kappa_allcoder_dfs <- function(merged_dfs) {
  list_name_kappa_allc <- "kappa_allcoder_dfs"
  list_kappa_allc <- list()

  for (i in 1:length(merged_dfs)) {
    kappa_allcoders_df_name <- str_c(names(merged_dfs)[i], "_kappas_allcoders", sep="")
    #get list of 'newest' code columns to calculate across
    newest_codes <- colnames(merged_dfs[[names(merged_dfs)[i]]])[which(str_detect(colnames(merged_dfs[[names(merged_dfs)[i]]]), "[A-Z]_code$"))]
    
    #select columns from each df to start with
    kappas_all_coders_start <- merged_dfs[[i]] %>% dplyr::select(Time, `Consensus Code`, all_of(newest_codes))
    
    #create the long df with coders' list of codes stacked on top of each other
    kappas_allcoders_df <- reshape2::melt(kappas_all_coders_start, id=c("Time", "Consensus Code"))
    #rename the new variables to be more initiutive
    names(kappas_allcoders_df) <- c("Time", "Consensus Code", "coder", "code")
    
    #create an empty df to hold the kappas
    kappas_allcoders <- data.frame(matrix(NA, nrow=1,ncol=1))
    rownames(kappas_allcoders) <- "all_coders"
    
    #calculate total kappa, put in df
          kappas_allcoders[1 , 1] <- kappa2(cbind(kappas_allcoders_df[["Consensus Code"]], kappas_allcoders_df[["code"]]))$value #calculate total kappa, add new variable 
          colnames(kappas_allcoders)[1] <- paste0(str_c("kappa", "total", sep="_")) #name the column "Kappa_total"
    #create 'coder' first column
    kappas_allcoders <- rownames_to_column(kappas_allcoders, var = "coder")
    #assign the kappa all coder df to the list
    list_kappa_allc[[i]] <-  kappas_allcoders 
    names(list_kappa_allc)[i] <- kappa_allcoders_df_name
  }
  #assign the list to the global environment
  assign(list_name_kappa_allc, list_kappa_allc, envir=.GlobalEnv)
}

#apply the function
create_kappa_allcoder_dfs(merged_dfs)
```


## Merge kappas and % agreement dfs for each participant
NOTE: order of the dfs in each list is the same because the original list used to create them (merged_dfs) is the same across both
```{r}
#bind rows for kappas and allcoders kappa dfs 
kappas_all_dfs <- map2(kappa_allcoder_dfs, kappa_dfs, dplyr::bind_rows)

#full join the percent agreementand kappas
indiv_dfs_test <- map2(perc_agree_dfs, kappas_all_dfs, dplyr::full_join, by = "coder") #for each entry of these lists, full join them by the coder column

#full join that to the baserates
indiv_dfs <- map2(indiv_dfs_test, baserate_dfs, dplyr::full_join, by = "coder")
```

## Write the summary files for each participant
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_cerfication_data/microFIMS_certification_behavior/"

#for each entry in the indiv_dfs kappas and % agreement list, write a .csv
lapply(1:length(indiv_dfs), function(i) write.csv(indiv_dfs[[i]], 
                                      file = paste0(str_c(path, sub("_%agree", "", names(indiv_dfs)[i]), "_summary.csv", sep="")), #call participantid_parent/child_summary
                                      row.names = FALSE))
```

# Create summary file for each coder aggregated across participants

```{r}
#create a really long dataframe from the merged dfs 
for (i in 1:(length(merged_dfs))) {
  merged_dfs[[i]]$participant_id <- names(merged_dfs)[i] #add participant id variable to each merged df for merging
}

#bind rows for all dfs together
mega_df <- bind_rows(merged_dfs)

#calculate percent total agreement across all participants
mega_df_summary <- mega_df %>% 
  summarise(across(contains("_agree"), ~sum(., na.rm=T)/sum(!is.na(.)), .names="{sub('_code_agree', '', col)}_total_%agree")) #sum of agree instances for each coder divided by tally of non-NA values

#transpose the df so that each coder's total % agree has their own row
mega_df_summary_t <- as.data.frame(t(mega_df_summary))
rownames(mega_df_summary_t) <- gsub('.{13}$', '', rownames(mega_df_summary_t)) #add coder rownames
colnames(mega_df_summary_t) <- "total_%agree" #make the column
mega_df_summary_t <- rownames_to_column(mega_df_summary_t, var = "coder") #name the first coder column

#create consolidated consensus code columns
#("neutral", "active", "positive", "uncodable", "withdraw", "offtask", "nonauto", "reject", "total")
mega_df <- mega_df %>% 
  mutate(cons_codes_consol = case_when(
    grepl("neutral", `Consensus Code`, ignore.case=T) ~ "neutral behavior",
    grepl("active", `Consensus Code`, ignore.case=T) ~ "active social engagement behavior",
    grepl("positive", `Consensus Code`, ignore.case=T) ~ "positive social communication behavior",
    grepl("withdraw", `Consensus Code`, ignore.case=T) ~ "withdrawal from interaction",
    grepl("off",  `Consensus Code`, ignore.case=T) ~ "off-task behavior",
    grepl("uncodable", `Consensus Code`, ignore.case=T) ~ "uncodable",
    grepl("auto", `Consensus Code`, ignore.case=T) ~ "non-autonomous behavior",
    grepl("reject", `Consensus Code`, ignore.case=T) ~ "rejecting others"
  ))

#calculate percent agreement by code (same formula as in individual dfs)
code_df <- mega_df %>% 
      group_by(cons_codes_consol) %>% 
      summarise(across(contains("_agree"), ~sum(., na.rm=T)/sum(!is.na(.)), .names="{sub('_code_agree', '', col)}")) %>% 
      as.data.frame()
#change the columns
#remove the NA row
code_df <- code_df %>% filter(!is.na(cons_codes_consol))
# first remember the new column names and row names 
names <- str_c(code_df$cons_codes_consol, "%agree", sep="_")
coders_code_df <- colnames(code_df)[-1]
# transpose all but the first column (names)
code_df_t <- as.data.frame(t(code_df[,-1]))
colnames(code_df_t) <- names #assign the column names, "code_%agree"
rownames(code_df_t) <- gsub('.{11}$', '', rownames(code_df_t)) #NEED TO CHANGE THIS TO BE REMOVE LAST X CHARACTERS
#name the first coder column 
code_df_t <- rownames_to_column(code_df_t, var = "coder")
code_df_t[1] <- coders_code_df

#get a list of coder initials
#select variables that end with code and have the first letter uppercase
coders_init_mega <- colnames(mega_df)[which(str_detect(colnames(mega_df), "_code$") & stri_locate_first_regex(colnames(mega_df), "[A-Z]")==1)] 
#remove NA values in coders (stri_locate_first_regex returns NA for columns that don't have any uppercase)
coders_mega <- coders_init_mega[!is.na(coders_init_mega)] 

#calculate kappas (basically the same thing that was done in loop above)
#("neutral", "active", "positive", "uncodable", "withdraw", "offtask", "nonauto", "reject", "total")
mega_df <- mutate(mega_df,
      #neutral
      across(ends_with("_code") & !contains("agree"), ~ifelse(grepl("neutral", ., ignore.case=TRUE), 1, 0), .names="neutral_{sub('_code', '', col)}"),
      neutral_consens = ifelse(grepl("neutral", `Consensus Code`, ignore.case=TRUE), 1, 0), 
      #active
      active_consens = ifelse(grepl("active", `Consensus Code`, ignore.case=TRUE), 1, 0), 
      across(ends_with("_code") & !contains("agree"), ~ifelse(grepl("active", ., ignore.case=TRUE), 1, 0), .names="active_{sub('_code', '', col)}"),
      #positive
      positive_consens = ifelse(grepl("positive", `Consensus Code`, ignore.case=TRUE), 1, 0),
      across(ends_with("_code") & !contains("agree"), ~ifelse(grepl("positive", .), 1, 0), .names="positive_{sub('_code', '', col)}"),
      #uncodable
      uncodable_consens = ifelse(grepl("uncodable", `Consensus Code`, ignore.case=TRUE), 1, 0),
      across(ends_with("_code") & !contains("agree"), ~ifelse(grepl("uncodable", ., ignore.case=TRUE), 1, 0), .names="uncodable_{sub('_code', '', col)}"),
      #withdraw
      withdraw_consens = ifelse(grepl("withdraw", `Consensus Code`, ignore.case=TRUE), 1, 0),
      across(ends_with("_code") & !contains("agree"), ~ifelse(grepl("withdraw", ., ignore.case=TRUE), 1, 0), .names="withdrawal_{sub('_code', '', col)}"),
      #offtask
      offtask_consens = ifelse(grepl("off", `Consensus Code`, ignore.case=TRUE), 1, 0),
      across(ends_with("_code") & !contains("agree"), ~ifelse(grepl("off", ., ignore.case=TRUE), 1, 0), .names="off-task_{sub('_code', '', col)}"),
      #nonauto
      nonauto_consens = ifelse(grepl("auto", `Consensus Code`, ignore.case=TRUE), 1, 0),
      across(ends_with("_code") & !contains("agree"), ~ifelse(grepl("auto", ., ignore.case=TRUE), 1, 0), .names="nonauto_{sub('_code', '', col)}"),
      #reject
      reject_consens = ifelse(grepl("reject", `Consensus Code`, ignore.case=TRUE), 1, 0),
      across(ends_with("_code") & !contains("agree"), ~ifelse(grepl("reject", ., ignore.case=TRUE), 1, 0), .names="rejecting_{sub('_code', '', col)}")
      )

codes <- c("neutral", "active", "positive", "uncodable", "withdrawal", "off-task", "nonauto", "rejecting", "total")

#calculate base rate for each code
base_rates <- as.data.frame(table(mega_df$cons_codes_consol)) %>% 
  mutate(base_rate_cons = Freq/sum(!is.na(mega_df$cons_codes_consol)))

# transpose all but the first column (names)
base_rates_t <- as.data.frame(t(base_rates[,-1]))

# assign column names based on values in Var1 column (first word)
colnames(base_rates_t) <- str_c("baserate", stringr::word(base_rates[,1], 1), sep="_")
rownames(base_rates_t) <- c("total_frequency", "consensus_codes") #extract the coder initials and assign as rownames
#name the first coder column 
baserate_consens <- dplyr::select(base_rates_t, -contains("end"), -contains("start"))

#create an empty df to hold the kappas and the base rates
kappas_mega <- data.frame(matrix(NA, nrow=length(coders_mega),ncol=1))
base_rates_coders <- data.frame(matrix(NA, nrow=length(coders_mega),ncol=(length(codes)-1))) #why is the nrow 1 less than N coders?

#calculate kappas and base rates for each coder and code, put in df
for (k in 1:length(coders_mega)) {
  for (j in 1:length(codes)){
    if (codes[j] != "total") { #for all codes except total kappa...
      
      #calculate base rates
      code_rate_coder = str_c(codes[j], sub('_code', '', coders_mega[k]), sep="_") #neutral_MA
      coder_codes = coders_mega[k]
      base_rates_coders[k, j] = sum(mega_df[[code_rate_coder]])/sum(!is.na(mega_df[[coder_codes]]))
      colnames(base_rates_coders)[j] <- str_c("baserate", codes[j], sep="_")
      rownames(base_rates_coders)[k] <- sub('_code', '', coders_mega[k])
      }
    else { #do a different procedure for total kappa
      coder_col_name = coders_mega[k]
      cons_col_init_name = "Consensus Code"
      kappas_mega[k , 1] <- kappa2(cbind(mega_df[[cons_col_init_name]], mega_df[[coder_col_name]]))$value
      colnames(kappas_mega)[1] <- paste0(str_c("kappa", "total", sep="_"))
      rownames(kappas_mega)[k] <- sub('_code', '', coders_mega[k])
    }
  }
}

#create 'coder' first column
kappas_mega <- rownames_to_column(kappas_mega, var = "coder")

#get rid of empty column in base_rate_coders df
#base_rates_coders <- dplyr::select(base_rates_coders, -X9)

#bind the base rates for consensus codes and each coder together
baserates_all <- base_rates_coders %>% bind_rows(baserate_consens)
baserates_all <- rownames_to_column(baserates_all, var = "coder")

#calculate kappas aggregated across all coders

#get list of 'newest' code columns to calculate across
newest_codes_mega <- colnames(mega_df)[which(str_detect(colnames(mega_df), "[A-Z]_code$"))]
    
#select columns from each df to start with
kappas_all_coders_start <- mega_df %>% dplyr::select(Time, `Consensus Code`, participant_id, all_of(newest_codes_mega))
    
#create the long df with coders' list of codes stacked on top of each other
kappas_allcoders_df <- reshape2::melt(kappas_all_coders_start, id=c("Time", "Consensus Code", "participant_id"))
#rename the new variables to be more initiutive
names(kappas_allcoders_df) <- c("Time", "Consensus Code", "participant_id", "coder", "code")
    
#each kappa code: add to that df the columns you created with 0 and 1 for each code above (THIS IS CURRENTLY VER REPETITIVE BUT WITH MELT FUNCTION CAN'T IMMEDIATELY THINK OF A DIFF WAY)
#("neutral", "active", "positive", "uncodable", "withdraw", "offtask", "nonauto", "reject", "total")
# kappas_allcoders_df <- mutate(kappas_allcoders_df,
#           neutral_code = ifelse(grepl("neutral", code, ignore.case=T), 1, 0),
#           neutral_consens = ifelse(grepl("neutral", `Consensus Code`, ignore.case=T), 1, 0),
#           active_code = ifelse(grepl("active", code, ignore.case=T), 1, 0),
#           active_consens = ifelse(grepl("active", `Consensus Code`, ignore.case=T), 1, 0),
#           positive_consens = ifelse(grepl("positive", `Consensus Code`, ignore.case=T), 1, 0),
#           positive_code = ifelse(grepl("positive", code, ignore.case=T), 1, 0),
#           uncodable_consens = ifelse(grepl("uncodable", `Consensus Code`, ignore.case=T), 1, 0),
#           uncodable_code = ifelse(grepl("uncodable", code, ignore.case=T), 1, 0),
#           withdraw_consens = ifelse(grepl("withdraw", `Consensus Code`, ignore.case=T), 1, 0),
#           withdraw_code = ifelse(grepl("withdraw", code, ignore.case=T), 1, 0),
#           offtask_consens = ifelse(grepl("off", `Consensus Code`, ignore.case=T), 1, 0),
#           offtask_code = ifelse(grepl("off", code, ignore.case=T), 1, 0),
#           nonauto_consens = ifelse(grepl("auto", `Consensus Code`, ignore.case=T), 1, 0),
#           nonauto_code = ifelse(grepl("auto", code, ignore.case=T), 1, 0),
#           reject_consens = ifelse(grepl("reject", `Consensus Code`, ignore.case=T), 1, 0),
#           reject_code = ifelse(grepl("reject", code, ignore.case=T), 1, 0)
#       )
#     
#create an empty df to hold the kappas
kappas_allcoders_mega <- data.frame(matrix(NA, nrow=1,ncol=1))
rownames(kappas_allcoders_mega) <- "all_coders"

#calculate total kappa across all coders, put in df
kappas_allcoders_mega[1 , 1] <- kappa2(cbind(kappas_allcoders_df[["Consensus Code"]], kappas_allcoders_df[["code"]]))$value #calculate total kappa, add new variable 
colnames(kappas_allcoders_mega)[1] <- paste0(str_c("kappa", "total", sep="_")) #name the column "Kappa_total"
  

#create 'coder' first column
kappas_allcoders_mega <- rownames_to_column(kappas_allcoders_mega, var = "coder")

#bind rows for kappa_allcoders and kappa for each coder
summary_kappas <- kappas_allcoders_mega %>% 
  bind_rows(kappas_mega)

#merge the mega_df_summary_t, code_df_t, kappas_mega dfs, baserate df
summary_final <- mega_df_summary_t %>% 
  full_join(code_df_t, by = "coder") %>% 
  full_join(summary_kappas, by = "coder") %>% 
  full_join(baserates_all, by = "coder")
```

## Average of dyad-specific kappas
We want to average all of the all_coders rows that is in the kappa_all_coders
```{r}

```

## Write summary file
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_cerfication_data/microFIMS_certification_behavior/"

#write the summary file csv
write_csv(summary_final, str_c(path, "all_summary.csv"))
```

# Calculate number of participants for each coder and across all coders
```{r}
#select columns from each df to start with
number_ps_start <- mega_df %>% dplyr::select(participant_id, all_of(newest_codes_mega))
    
#create the long df with coders' list of codes stacked on top of each other
number_ps <- reshape2::melt(number_ps_start, id=c("participant_id"))

np_summary <- number_ps %>% filter(!is.na(value)) %>%group_by(variable) %>% summarise(number_participants = n_distinct(participant_id)) #all coders coded 6 participants

#add row which is total number of unique participants
np_summary<- np_summary %>% 
  add_row(variable = "all_coders", number_participants = length(unique(mega_df$participant_id))) %>% 
  dplyr::rename(coder = variable)
```

## Write number of participants file
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_cerfication_data/microFIMS_certification_behavior/"

#write the summary file csv
write_csv(np_summary, str_c(path, "number_participants.csv"))
```

# Calculate reliability (total kappa only) for all possible pairs of coders
Per participant 
n(n-1)/2
```{r}
# for all the merged_dfs, create a "coder1_coder2_agree" column; one column for each possible combination of coders (2 coders = 1 column, 3 codres = 2 columns, 4 coders = 6 columns)
calc_reliability_certification <- function(merged_dfs) {
  list_name <- "reliability_certification"
  list <- list()
  for (i in 1:length(merged_dfs)) {
    #create the final df name
    if (ncol(merged_dfs[[i]]) > 8) { #for all merged dfs where there is more than 1 coder
    final_df_name <- str_c(names(merged_dfs)[i], "_reliability", sep="")
    
    #get list of coder columns
    coders <- colnames(merged_dfs[[names(merged_dfs)[i]]])[which(str_detect(colnames(merged_dfs[[names(merged_dfs)[i]]]), "_code$"))] 
    
    #create empty dfs to hold the kappas in
    participant_summary_df <- data.frame(matrix(NA, nrow=((length(coders)*(length(coders)-1))/2), ncol=1)) # column will be "total_kappa" and rows will be combinatinos of coders (formula n(n-1)/2 is number of unique pairs in a set)
    
    # generate pairs of coders (e.g, coder1/coder2, coder1/coder3, coder2/coder3)
    generate_pairs <- function(n) {
    pairs <- vector("list", length = n*(n-1)/2)
    idx <- 1
    for (i in 1:(n-1)) {
      for (j in (i+1):n) {
        pairs[[idx]] <- c(i, j)
        idx <- idx + 1
      }
    }
    return(pairs)
    }

    all_pairs <- generate_pairs(length(coders))
    
    for (j in 1:length(all_pairs)){
    #calculate total kappa for each pair
    participant_summary_df[j , 1] <- kappa2(cbind(merged_dfs[[i]][[coders[all_pairs[[j]][1]]]], merged_dfs[[i]][[coders[all_pairs[[j]][2]]]]))$value #calculate total kappa, add new variable 
    colnames(participant_summary_df)[1] <- paste0("total_kappa")
    rownames(participant_summary_df)[j] <- paste0(str_c(sub("_code", "", coders[all_pairs[[j]][1]]), sub("_code", "", coders[all_pairs[[j]][2]]), sep="_")) 
    }

    #create 'coder' first column
    participant_summary_df <- rownames_to_column(participant_summary_df, var = "coder_pair")
    list[[i]] <-  participant_summary_df 
    names(list)[i] <- final_df_name
  }
  #assign the completed list to the global environment
  assign(list_name, list, envir=.GlobalEnv)
  }
}

#apply the function
calc_reliability_certification(merged_dfs) #try this again when MA's NA values have been removed 
```

## Write reliability for all pairs of coders to file
```{r}
path <- "../../FIMS/FIMS_micro_coding/MicroFIMS Core Team Training/microFIMS_cerfication_data/microFIMS_certification_behavior/"

lapply(1:length(reliability_certification), function(i) write.csv(reliability_certification[[i]], 
                                      file = paste0(str_c(path, names(reliability_certification)[i]), ".csv"), # call MBB074_reliability
                                      row.names = FALSE))
```

